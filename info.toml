# The format version is an indicator of the compatibility of third-party exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of third-party
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = 1

# Optional multi-line message to be shown to users when just starting with the exercises.
welcome_message = """Bienvenue dans la version traduite de Rustlings."""

# Optional multi-line message to be shown to users after finishing all exercises.
final_message = """Bravo ! J'espère que ces exercices vous auront été utiles."""

# INTRO

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
skip_check_unsolved = true
hint = """
Tape `n` (pour 'next') afin de passer à l'exercice suivant.
Tu pourrais avoir besoin d'appuyer sur ENTRÉE après avoir tapé `n`."""

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """
Le compilateur nous informe que nous avons mal écrit le nom de la macro d'affichage (print macro). Il suggère une alternative."""

# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
Il manque le mot-clé `let` dans la déclaration de variable à l'intérieur de la fonction `main`."""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """
Le message du compilateur indique que Rust ne peut pas déduire le type de la variable `x` avec ce qui est actuellement écrit.

Que se passe-t-il si tu annotes la première ligne dans la fonction `main` avec un type?

Que se passe-t-il si tu donnes une valeur à `x`?

Que se passe-t-il si tu fais les deux?

Quel type devrait avoir `x`, de toute façon?

Et si `x` est du même type que `10`? Et s'il est d'un type différent?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """
Dans cet exercice, nous avons créé une variable dans la fonction `main`, et nous essayons de l'utiliser à la ligne suivante, mais nous ne lui avons pas donné de valeur.

Nous ne pouvons pas afficher quelque chose qui n'existe pas ; essaie de donner une valeur à `x` !

C'est une erreur qui peut causer des bugs et qui est très facile à faire dans n'importe quel langage de programmation — heureusement, le compilateur Rust l'a détectée pour nous !"""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
En Rust, les variables sont immuables par défaut. Mais ici, nous essayons d'assigner une valeur différente à `x` ! Il existe un mot-clé que nous pouvons utiliser pour rendre une liaison de variable mutable."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
Dans `variables4`, nous avons déjà appris comment rendre une variable immuable mutable en utilisant un mot-clé spécial. Malheureusement, cela ne nous aide pas beaucoup dans cet exercice car nous voulons assigner une valeur de type différent à une variable existante. Parfois, tu peux aussi vouloir réutiliser des noms de variables existants parce que tu convertis simplement des valeurs vers différents types comme dans cet exercice.
Heureusement, Rust a une solution puissante à ce problème : le 'Shadowing' (masquage) !
Tu peux en savoir plus sur le 'Masquage' dans la section 'Les variables et la mutabilité' du Rust Book(fr) :
https://jimskapt.github.io/rust-book-fr/ch03-01-variables-and-mutability.html#le-masquage
Essaie de résoudre cet exercice en utilisant cette technique."""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """
Nous connaissons les variables et la mutabilité, mais il existe un autre type important de variable disponible : les constantes.

Les constantes sont toujours immuables. Elles sont déclarées avec le mot-clé `const` au lieu de `let`.

Le type des constantes doit toujours être annoté.

Tu peux en savoir plus sur les constantes et les différences entre les variables et les constantes dans la section 'Les Constantes' du chapitre 'Les variables et la mutabilité' du Rust Book(fr) :
https://jimskapt.github.io/rust-book-fr/ch03-01-variables-and-mutability.html#les-constantes"""

# FUNCTIONS

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """
La fonction `main` appelle une fonction qui, selon le programme, devrait exister, mais cette fonction n'existe pas. Le programme s'attend à ce que cette fonction ait le nom `call_me`. Il s'attend également à ce que cette fonction ne prenne aucun argument et ne renvoie aucune valeur. Ça ressemble beaucoup à `main`, n'est-ce pas ?"""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """
Rust exige que toutes les parties de la signature d'une fonction aient des annotations de type, mais `call_me` n'a pas d'annotation de type pour `num`."""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """
Cette fois, la *déclaration* de la fonction est correcte, mais il y a un problème à l'endroit où nous appelons la fonction."""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """
Le message d'erreur pointe vers la fonction `sale_price` et indique qu'il attend un type après `->`. C'est là que devrait se trouver le type de retour de la fonction. Jette un coup d'œil à la fonction `is_even` pour voir un exemple !"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """
C'est une erreur très courante qui peut être corrigée en supprimant un seul caractère. 
Elle se produit parce que Rust fait la distinction entre les expressions et les instructions :
les expressions renvoient une valeur basée sur leur(s) opérande(s), tandis que les instructions renvoient simplement 
un type `()` qui se comporte comme `void` en C/C++.
Nous voulons renvoyer une valeur de type `i32` de la fonction `square`, mais
elle renvoie le type `()`.
Il existe deux solutions :
1. Ajouter le mot-clé `return` avant `num * num;`
2. Supprimer le point-virgule `;` après `num * num`"""

# IF

[[exercises]]
name = "if1"
dir = "03_if"
hint = """
Il est possible de faire cela en une seule ligne si tu le souhaites !

Quelques exemples similaires dans d'autres langages :
- En C(++) ce serait : `a > b ? a : b`
- En Python ce serait : `a if a > b else b`

N'oublie pas qu'en Rust :
- La condition `if` n'a pas besoin d'être entourée de parenthèses
- Les conditionnels `if`/`else` sont des expressions
- Chaque condition est suivie d'un bloc `{}`"""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """
Pour cette première erreur de compilation, il est important, en Rust, que chaque bloc conditionnel retourne le même type !

Pour faire passer les tests, tu auras besoin de quelques conditions vérifiant différentes valeurs d'entrée. Lis les tests pour découvrir ce qu'ils attendent."""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """
En Rust, chaque *branche* d'une expression `if` doit retourner le même type de valeur.
Assure-toi que le type soit cohérent dans toutes les *branches*."""

# QUIZ 1

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = "Pas d'indices cette fois-ci ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
test = false
hint = """
En Rust, une valeur booléenne peut être inversée en utilisant l'opérateur `!` placé devant.
Exemple : `!true == false`
Cela fonctionne également avec les variables booléennes."""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
test = false
hint = "Pas d'indices cette fois-ci ;)"

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """
Il existe un raccourci pour initialiser des tableaux d'une certaine taille qui ne
te demande pas de saisir 100 éléments (mais tu peux certainement le faire si tu le souhaites !).
Par exemple, tu peux faire :
```
let array = ["On arrive bientôt ?"; 100];
```
Bonus : quelles autres choses pourrais-tu avoir qui retourneraient `true`
pour `a.len() >= 100` ?"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """
Regarde la section 'Comprendre la propriété -> Slices -> Autres Slices' 
du rust book (fr) : https://jimskapt.github.io/rust-book-fr/ch04-03-slices.html et utilise les
indices de début et de fin (plus un) des éléments du tableau que tu souhaites
avoir dans la slice.
Si tu te demandes pourquoi le premier argument de `assert_eq!` n'a pas
d'esperluette pour une référence alors que le second argument est une référence, jette un œil
au chapitre sur la coercition du nomicon :
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """
Regarde la section 'Types de données -> Le type Tuple' du rust book (fr) :
https://jimskapt.github.io/rust-book-fr/ch03-02-data-types.html#le-type-tuple
Particulièrement la partie sur la destructuration (avant-dernier exemple dans la section).
Tu auras besoin de créer un pattern pour lier `name` et `age` aux parties appropriées du tuple."""

[[exercises]]
name = "primitive_types6"
dir = "04_primitive_types"
hint = """
Bien que tu pourrais utiliser un `let` avec destructuration pour le tuple ici, essaie plutôt 
d'y accéder par indexation, comme expliqué dans le dernier exemple de la
section 'Types de données -> Le type Tuple' du rust book (fr) :
https://jimskapt.github.io/rust-book-fr/ch03-02-data-types.html#le-type-tuple
Maintenant, tu as une nouvelle corde à ton arc !"""

# VECS

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """
En Rust, il existe deux façons de définir un Vector (vecteur).
1. Une façon est d'utiliser la fonction `Vec::new()` pour créer un nouveau vecteur
   et le remplir avec la méthode `push()`.
2. La seconde façon est d'utiliser la macro `vec![]` et définir tes éléments
   à l'intérieur des crochets. Cette façon est plus simple quand tu connais exactement
   les valeurs initiales.
Consulte ce chapitre : https://jimskapt.github.io/rust-book-fr/ch08-01-vectors.html
du Rust book pour en savoir plus."""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """
Dans la première fonction, nous créons un vecteur vide et voulons y ajouter de nouveaux éléments.
Dans la deuxième fonction, nous mappons les valeurs de l'entrée et les collectons dans un vecteur.

Après avoir complété les deux fonctions, décide par toi-même quelle approche tu préfères.
Selon toi, quel est le modèle le plus couramment utilisé par les développeurs Rust ?"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
dir = "06_move_semantics"
hint = """
Donc tu as l'erreur "cannot borrow `vec` as mutable, as it is not declared as
mutable" (impossible d'emprunter `vec` comme mutable, car il n'est pas déclaré comme
mutable) sur la ligne où nous ajoutons un élément au vecteur, n'est-ce pas ?

La solution consiste à ajouter un seul mot-clé, et ce n'est PAS sur
la ligne où nous faisons un ajout au vecteur (où se trouve l'erreur).

Essaie d'accéder à `vec0` après avoir appelé `fill_vec()`. Regarde ce qui se passe !"""

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """
Quand tu exécutes cet exercice pour la première fois, tu remarqueras une erreur concernant
"borrow of moved value" (emprunt d'une valeur déplacée). En Rust, quand un argument est passé à une fonction et
qu'il n'est pas explicitement retourné, tu ne peux plus utiliser la variable originale.
On appelle cela "déplacer" (moving) une variable. Quand nous passons `vec0` dans `fill_vec`, elle est
"déplacée" dans `vec1`, ce qui signifie que nous ne pouvons plus accéder à `vec0`.

Tu pourrais créer une autre version séparée des données contenues dans `vec0` et
la passer à `fill_vec` à la place. Cela s'appelle cloning (clonage) en Rust."""

[[exercises]]
name = "move_semantics3"
dir = "06_move_semantics"
hint = """
La différence entre celui-ci et les précédents est que la première ligne
de `fn fill_vec` qui avait `let mut vec = vec;` n'est plus là. Tu peux,
au lieu de remettre cette ligne, ajouter `mut` à un endroit qui transformera
un binding (liaison) existant en binding mutable plutôt qu'immutable :)"""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """
Réfléchis attentivement à la portée (scope) dans laquelle chaque référence mutable est
active. Est-ce utile de mettre à jour la valeur de `x` immédiatement après
avoir pris la référence mutable ?
En savoir plus sur les 'Mutable References' (références mutables) dans la section 'References and Borrowing' du rust book :
https://jimskapt.github.io/rust-book-fr/ch04-02-references-and-borrowing.html#les-r%C3%A9f%C3%A9rences-mutables"""

[[exercises]]
name = "move_semantics5"
dir = "06_move_semantics"
test = false
hint = """
Pour trouver la réponse, tu peux consulter la section "References and Borrowing" du rust book :
https://jimskapt.github.io/rust-book-fr/ch04-02-references-and-borrowing.html

Le premier problème est que `get_char` prend possession (ownership) de la chaîne. Donc
`data` est déplacée et ne peut pas être utilisée pour `string_uppercase`. `data` est d'abord déplacée vers
`get_char`, ce qui signifie que `string_uppercase` ne peut pas manipuler les données.

Une fois que tu auras résolu ce problème, la signature de la fonction `string_uppercase` devra également
être ajustée."""

# STRUCTS

[[exercises]]
name = "structs1"
dir = "07_structs"
hint = """
Rust possède plus d'un type de struct. Trois en fait, toutes les variantes sont utilisées pour 
regrouper des données liées.

Il y a les structs régulières. Ce sont des collections nommées de données liées stockées dans 
des fields (champs).

Les tuple structs sont essentiellement des tuples nommés.

Enfin, les unit structs. Elles n'ont pas de champs et sont utiles pour les generics (génériques).

Dans cet exercice, tu dois compléter et implémenter un exemple de chaque type.
Pour en savoir plus sur les structs, consulte le rust book :
https://jimskapt.github.io/rust-book-fr/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
dir = "07_structs"
hint = """
Créer des instances de structs est facile, il suffit d'assigner des valeurs 
à ses fields (champs).

Il existe cependant quelques raccourcis qui peuvent être utilisés lors de l'instanciation des structs.
Jette un œil au rust book pour en savoir plus :
https://jimskapt.github.io/rust-book-fr/ch05-01-defining-structs.html#cr%C3%A9er-des-instances-%C3%A0-partir-dautres-instances-avec-la-syntaxe-de-mise-%C3%A0-jour-de-structure"""

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """
Pour `is_international` : Qu'est-ce qui rend un colis international ? Cela semble lié 
aux endroits par lesquels il passe, n'est-ce pas ?

Pour `get_fees` : Cette méthode prend un argument supplémentaire, y a-t-il un field (champ) dans 
la struct `Package` auquel cela se rapporte ?

Consulte le rust book pour en savoir plus sur les implémentations de méthodes :
https://jimskapt.github.io/rust-book-fr/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = "Pas d'indices cette fois-ci ;)"

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """
Tu peux créer des énumérations qui ont différentes variantes avec différents types tels que des structs anonymes, des structs, une simple string (chaîne de caractères), des tuples, sans données, etc."""

[[exercises]]
name = "enums3"
dir = "08_enums"
hint = """
Commence par définir des énumérations pour compiler le code sans erreurs.

Ensuite, crée une expression match dans `process()`.

Note que tu dois déconstruire certaines variantes du message dans l'expression match pour obtenir les valeurs de la variante."""

# STRINGS

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """
La fonction `current_favorite_color` renvoie actuellement un string slice (tranche de chaîne de caractères) avec la durée de vie `'static`. Nous le savons parce que les données de la chaîne existent directement dans notre code -- elles ne proviennent pas d'un fichier, d'une saisie utilisateur ou d'un autre programme -- donc elles vivront aussi longtemps que notre programme.

Mais c'est toujours un string slice. Il existe une façon de créer un `String` en convertissant un string slice, comme expliqué dans le chapitre sur les Strings du rust book, et une autre méthode qui utilise le trait `From`.
https://jimskapt.github.io/rust-book-fr/ch08-02-strings.html"""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """
Oui, ce serait vraiment facile de corriger cela en changeant simplement la valeur liée à `word` pour qu'elle soit un string slice (tranche de chaîne) au lieu d'un `String`, n'est-ce pas ? Il existe cependant une façon d'ajouter un seul caractère à l'instruction `if` qui permettra de contraindre le `String` en un string slice.

Note : Si tu es intéressé(e) par comprendre comment fonctionne ce type de conversion de référence, tu peux avancer dans le rust book et lire cette partie dans le chapitre sur les smart pointers (pointeurs intelligents) :
https://jimskapt.github.io/rust-book-fr/ch15-02-deref.html#extrapolation-de-d%C3%A9r%C3%A9f%C3%A9rencement-implicite-avec-les-fonctions-et-les-m%C3%A9thodes"""

[[exercises]]
name = "strings3"
dir = "09_strings"
hint = """
Il existe de nombreuses fonctions utiles dans la bibliothèque standard pour les strings (chaînes de caractères). Essayons d'en utiliser quelques-unes :
https://doc.rust-lang.org/std/string/struct.String.html#method.trim

Pour la méthode `compose_me` : Tu peux soit utiliser la macro `format!`, soit convertir la tranche de chaîne en une chaîne possédée, que tu pourras ensuite étendre librement.

Pour la méthode `replace_me`, tu peux consulter la méthode `replace` :
https://doc.rust-lang.org/std/string/struct.String.html#method.replace"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """
Remplace `placeholder` par `string` ou `string_slice` dans la fonction `main`.

Exemple :
`placeholder("blue");`
doit devenir
`string_slice("blue");`
car "blue" est un `&str`, pas un `String`."""

# MODULES

[[exercises]]
name = "modules1"
dir = "10_modules"
test = false
hint = """
Tout est privé par défaut en Rust. Mais il existe un mot-clé qu'on peut utiliser pour rendre quelque chose public !"""

[[exercises]]
name = "modules2"
dir = "10_modules"
test = false
hint = """
Le module `delicious_snacks` essaie de présenter une interface externe différente de sa structure interne (les modules `fruits` et `veggies` et leurs constantes associées). Complète les déclarations `use` pour correspondre aux utilisations dans `main` et trouve le mot-clé manquant pour les deux constantes.

Pour en savoir plus dans le rust book:
https://jimskapt.github.io/rust-book-fr/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#r%C3%A9exporter-des-%C3%A9l%C3%A9ments-avec-pub-use"""

[[exercises]]
name = "modules3"
dir = "10_modules"
test = false
hint = """
`UNIX_EPOCH` et `SystemTime` sont déclarés dans le module `std::time`. Ajoute une déclaration `use` pour ces deux éléments afin de les intégrer dans la portée. Tu peux utiliser des chemins imbriqués pour les importer en une seule ligne."""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
dir = "11_hashmaps"
hint = """
Le nombre de fruits devrait être au moins 5 et tu dois inclure au moins 3
types différents de fruits."""

[[exercises]]
name = "hashmaps2"
dir = "11_hashmaps"
hint = """
Utilise les méthodes `entry()` et `or_insert()` de `HashMap` pour accomplir cela.

Pour en savoir plus, renvez-vous dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch08-03-hash-maps.html#ajouter-une-valeur-seulement-si-la-cl%C3%A9-na-pas-d%C3%A9j%C3%A0-de-valeur"""

[[exercises]]
name = "hashmaps3"
dir = "11_hashmaps"
hint = """
Indice 1 : Utilise les méthodes `entry()` et `or_default()` de `HashMap` pour insérer la
       valeur par défaut de `TeamScores` si une équipe n'existe pas encore dans la table.

Indice 2 : S'il existe déjà une entrée pour une clé donnée, la valeur renvoyée par
       `entry()` peut être mise à jour en fonction de la valeur existante.

Pour en savoir plus, rendez-vous dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch08-03-hash-maps.html#modifier-une-valeur-en-fonction-de-lancienne-valeur"""

# QUIZ 2

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = "L'opérateur `+` peut concaténer une `String` avec un `&str` (string slice)."

# OPTIONS

[[exercises]]
name = "options1"
dir = "12_options"
hint = """
Les Options peuvent avoir une valeur `Some`, avec une valeur interne, ou une valeur `None`, sans valeur interne.

Il existe plusieurs façons d'accéder à la valeur interne, tu peux utiliser `unwrap`, ou faire du pattern matching (filtrage par motif). Unwrap est le plus simple, mais comment le faire en toute sécurité pour éviter que ton programme ne panique plus tard ?"""

[[exercises]]
name = "options2"
dir = "12_options"
hint = """
Jette un œil à :

- https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
- https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

N'oublie pas que les `Option` peuvent être imbriquées dans les expressions if-let et while-let.

Par exemple : `if let Some(Some(x)) = y`

Voir aussi `Option::flatten`"""

[[exercises]]
name = "options3"
dir = "12_options"
test = false
hint = """
Le compilateur indique qu'un déplacement partiel (partial move) s'est produit dans l'instruction `match`. Comment éviter cela ? Le compilateur montre la correction nécessaire.

Après avoir effectué la correction suggérée par le compilateur, lis la page de documentation associée :
https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
dir = "13_error_handling"
hint = """
`Ok` et `Err` sont les deux variantes de `Result`, donc ce que les tests demandent, 
c'est que `generate_nametag_text` renvoie un `Result` au lieu d'un `Option`.

Pour effectuer cette modification, tu devras :
  - mettre à jour le type de retour dans la signature de la fonction pour qu'il soit un `Result<String, 
    String>` qui pourrait avoir les variantes `Ok(String)` et `Err(String)`
  - modifier le corps de la fonction pour renvoyer `Ok(…)` là où il 
    renvoie actuellement `Some(…)`
  - modifier le corps de la fonction pour renvoyer `Err(message d'erreur)` là où il
    renvoie actuellement `None`"""

[[exercises]]
name = "errors2"
dir = "13_error_handling"
hint = """
Une façon de gérer cela est d'utiliser une instruction `match` sur
`item_quantity.parse::<i32>()` où les cas sont `Ok(something)` et
`Err(something)`.

Ce modèle est très courant en Rust, donc il existe l'opérateur `?` qui
fait pratiquement ce que tu ferais avec cette instruction match !

Jette un œil à cette section du chapitre "Error Handling" (Gestion des erreurs) :
https://jimskapt.github.io/rust-book-fr/ch09-02-recoverable-errors-with-result.html#un-raccourci-pour-propager-les-erreurs--lop%C3%A9rateur-"""

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """
Si d'autres fonctions peuvent renvoyer un `Result` (résultat), pourquoi `main` ne le pourrait-il pas ? C'est une convention assez courante de renvoyer quelque chose comme `Result<(), TypeErreur>` depuis ta fonction `main`.

Le type unitaire `()` est là car rien n'est vraiment nécessaire en termes de résultat positif."""

[[exercises]]
name = "errors4"
dir = "13_error_handling"
hint = """
La méthode `PositiveNonzeroInteger::new` crée toujours une nouvelle instance et renvoie un résultat `Ok`. Mais elle devrait effectuer des vérifications, renvoyer un `Err` si ces vérifications échouent, et ne renvoyer un `Ok` que si ces vérifications déterminent que tout est… correct :)"""

[[exercises]]
name = "errors5"
dir = "13_error_handling"
test = false
hint = """
Il existe deux types de `Result` différents produits au sein de la fonction `main`, qui sont propagés à l'aide des opérateurs `?`. Comment déclarer un type de retour pour la fonction `main` qui permette les deux ?

En coulisses, l'opérateur `?` appelle `From::from` sur la valeur d'erreur pour la convertir en un objet de trait boîté (trait object), un `Box<dyn Error>`. Cet objet de trait boîté est polymorphique, et comme toutes les erreurs implémentent le trait `Error`, on peut capturer de nombreuses erreurs différentes dans un seul objet `Box`.

Consulte cette section du Livre :
https://jimskapt.github.io/rust-book-fr/ch09-02-recoverable-errors-with-result.html#un-raccourci-pour-propager-les-erreurs--lop%C3%A9rateur-

Lis plus sur le boxing des erreurs :
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Lis plus sur l'utilisation de l'opérateur `?` avec des erreurs boîtées :
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "errors6"
dir = "13_error_handling"
hint = """
Cet exercice utilise une version complétée de `PositiveNonzeroInteger` des exercices précédents.

Sous la ligne où `TODO` te demande de faire une modification, il y a un exemple d'utilisation de la méthode `map_err()` sur un `Result` pour transformer un type d'erreur en un autre. Essaie d'utiliser quelque chose de similaire sur le `Result` de `parse()`. Tu pourras ensuite utiliser l'opérateur `?` pour un retour anticipé.

Plus d'info sur `map_err()` dans la documentation `std::result` :
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
dir = "14_generics"
test = false
hint = """
Les vecteurs (Vectors) en Rust utilisent des génériques pour créer des tableaux de taille dynamique de n'importe quel type. 
Si le vecteur `numbers` a le type `Vec`, alors nous ne pouvons pousser que des valeurs de type `T`. En utilisant `into()` avant de pousser, nous demandons au compilateur de convertir `n1` et `n2` en `T`. Mais le compilateur ne connaît pas encore `T` et a besoin d'une annotation de type. 

`u8` et `i8` peuvent tous deux être convertis en `i16`, `i32` et `i64`. Choisis un type générique pour le vecteur."""

[[exercises]]
name = "generics2"
dir = "14_generics"
hint = """
Voir le chapitre correspondant dans le rust book:
https://jimskapt.github.io/rust-book-fr/ch10-01-syntax.html#dans-la-d%C3%A9finition-des-m%C3%A9thodes"""

# TRAITS

[[exercises]]
name = "traits1"
dir = "15_traits"
hint = """
En savoir plus sur les traits (traits) dans The Book :
https://jimskapt.github.io/rust-book-fr/ch10-02-traits.html

L'opérateur `+` peut concaténer un `String` avec un `&str`."""

[[exercises]]
name = "traits2"
dir = "15_traits"
hint = """
Le trait prend possession de `self` et retourne `Self`.

Bien que la signature de `append_bar` dans le trait prenne `self` comme argument,
l'implémentation peut prendre `mut self` à la place. C'est possible car 
la valeur est de toute façon possédée."""

[[exercises]]
name = "traits3"
dir = "15_traits"
hint = """
Les traits peuvent avoir une implémentation par défaut pour des fonctions. Les types de données qui
implémentent le trait peuvent alors utiliser la version par défaut de ces fonctions
s'ils choisissent de ne pas implémenter la fonction eux-mêmes.

Voir dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch10-02-traits.html#impl%C3%A9mentations-par-d%C3%A9faut"""

[[exercises]]
name = "traits4"
dir = "15_traits"
hint = """
Au lieu d'utiliser des types concrets (concrete types) comme paramètres, tu peux utiliser des traits (traits). Essaie de remplacer
`???` par `impl [que mettre ici ?]`.

Voir dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch10-02-traits.html#des-traits-en-param%C3%A8tres"""

[[exercises]]
name = "traits5"
dir = "15_traits"
hint = """
Pour s'assurer qu'un paramètre implémente plusieurs traits, utilise la syntaxe '+'. Essaie
de remplacer `???` par 'impl [premier trait] + [second trait]'.

Voir dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch10-02-traits.html#renseigner-plusieurs-traits-li%C3%A9s-avec-la-syntaxe-"""

# QUIZ 3

[[exercises]]
name = "quiz3"
dir = "quizzes"
hint = """
Pour résoudre ce défi, tu dois te rappeler tes connaissances sur les traits (traits), en particulier la "Syntaxe des bornes de traits (Trait Bound Syntax)":
https://jimskapt.github.io/rust-book-fr/ch10-02-traits.html#la-syntaxe-du-trait-li%C3%A9

Voici comment spécifier une borne de trait pour un bloc d'implémentation :
`impl<T: Trait1 + Trait2 + …> for Foo<T> { … }`

Tu pourrais avoir besoin de ceci :
`use std::fmt::Display;`"""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
dir = "16_lifetimes"
hint = """
Laisse le compilateur te guider. Jette aussi un coup d'œil au rust book si tu as besoin d'aide :
https://jimskapt.github.io/rust-book-fr/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
dir = "16_lifetimes"
test = false
hint = """
Rappelle-toi que la durée de vie générique (lifetime) `'a` prendra la durée de vie concrète qui est égale à la plus petite des durées de vie de `x` et `y`.

Tu as au moins deux solutions pour résoudre ce problème sans supprimer le bloc interne :
1. Déplace la déclaration de `string2` pour qu'elle vive aussi longtemps que `string1` (comment `result` est-il déclaré ?)
2. Déplace le `println!` dans le bloc interne"""

[[exercises]]
name = "lifetimes3"
dir = "16_lifetimes"
test = false
hint = """Laisse le compilateur te guider :)"""

# TESTS

[[exercises]]
name = "tests1"
dir = "17_tests"
hint = """
`assert!` est une macro qui nécessite un argument. Selon la valeur de l'argument, `assert!` ne fera rien (auquel cas le test passera) ou `assert!` provoquera une panique (failure) (auquel cas le test échouera).

Donc essaie de donner différentes valeurs à `assert!` et regarde lesquelles se compilent, lesquelles passent et lesquelles échouent :)

Si tu veux vérifier `false`, tu peux inverser le résultat de ce que tu vérifies en utilisant `!`, comme `assert!(!…)`."""

[[exercises]]
name = "tests2"
dir = "17_tests"
hint = """
`assert_eq!` est une macro qui prend deux arguments et les compare. Essaie de lui donner deux valeurs identiques ! Essaie de lui donner deux arguments différents ! Essaie d'inverser l'ordre des arguments !"""

[[exercises]]
name = "tests3"
dir = "17_tests"
hint = """
Nous attendons à ce que la méthode `Rectangle::new` provoque une panique (panic) pour des valeurs négatives.

Pour gérer cela, tu dois ajouter un attribut spécial à la fonction de test.

Tu peux te référer au rust book :
https://jimskapt.github.io/rust-book-fr/ch11-01-writing-tests.html#v%C3%A9rifier-le-fonctionnement-des-paniques-avec-should_panic"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
dir = "18_iterators"
hint = """
Un iterator (itérateur) parcourt tous les éléments d'une collection, mais que se passe-t-il quand nous n'avons plus d'éléments? Qu'est-ce qu'on devrait attendre ici? Si tu es bloqué, jette un œil à https://doc.rust-lang.org/std/iter/trait.Iterator.html"""

[[exercises]]
name = "iterators2"
dir = "18_iterators"
hint = """
`capitalize_first` :

La variable `first` est un `char`. Elle doit être mise en majuscule et ajoutée aux
caractères restants dans `chars` afin de renvoyer la bonne `String`.

Les caractères restants dans `chars` peuvent être vus comme une tranche de chaîne en utilisant la
méthode `as_str`.

La documentation pour `char` contient de nombreuses méthodes utiles.
https://doc.rust-lang.org/std/primitive.char.html

Utilise `char::to_uppercase`. Cela renvoie un iterator (itérateur) qui peut être converti en
`String`.

`capitalize_words_vector` :

Crée un iterator à partir de la tranche. Transforme les valeurs itérées en appliquant
la fonction `capitalize_first`. N'oublie pas de `collect` l'iterator.

`capitalize_words_string` :

C'est étonnamment similaire à la solution précédente. `collect` est très
puissant et très général. Rust a juste besoin de connaître le type souhaité."""

[[exercises]]
name = "iterators3"
dir = "18_iterators"
hint = """
La fonction `divide` doit renvoyer l'erreur appropriée quand le diviseur est 0 ou
quand la division entière n'est pas possible.

La variable `division_results` doit être collectée dans un type de collection.

La fonction `result_with_list` doit renvoyer un seul `Result` où le
cas de succès est un vecteur d'entiers et le cas d'échec est un `DivisionError`.

La fonction `list_of_results` doit renvoyer un vecteur de résultats.

Voir https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect pour
comprendre comment le trait `FromIterator` est utilisé dans `collect()`. Ce trait est VRAIMENT
puissant ! Il peut rendre la solution de cet exercice beaucoup plus simple."""

[[exercises]]
name = "iterators4"
dir = "18_iterators"
hint = """
Dans un langage impératif, tu pourrais écrire une boucle `for` qui met à jour une variable mutable. Ou, tu pourrais écrire du code utilisant la récursion et une clause match. En Rust, tu peux adopter une autre approche fonctionnelle, en calculant la factorielle élégamment avec des ranges (plages) et des iterators.

Jette un œil aux méthodes `fold` et `rfold` !"""

[[exercises]]
name = "iterators5"
dir = "18_iterators"
hint = """
La documentation du trait `std::iter::Iterator` contient de nombreuses méthodes 
qui seraient utiles ici.

La variable `collection` dans `count_collection_iterator` est une tranche de 
`HashMap`. Elle doit être convertie en iterator (itérateur) afin d'utiliser les 
méthodes d'itérateur.

La méthode `fold` peut être utile dans la fonction `count_collection_iterator`.

Pour un défi supplémentaire, consulte la documentation de `Iterator` pour trouver 
une méthode différente qui pourrait rendre ton code plus compact que l'utilisation de `fold`."""

# SMART POINTERS

[[exercises]]
name = "box1"
dir = "19_smart_pointers"
hint = """
Le message du compilateur devrait t'aider : Comme nous ne pouvons pas stocker la valeur du type réel lors du travail avec des types récursifs (recursive types), nous devons stocker une référence (pointeur) vers sa valeur.

Tu devrais donc placer ta `List` à l'intérieur d'une `Box`. Plus de détails dans Le Livre (The Book) :
https://jimskapt.github.io/rust-book-fr/ch15-01-box.html#pouvoir-utiliser-des-types-r%C3%A9cursifs-gr%C3%A2ce-aux-boites

Créer une liste vide devrait être assez simple (Indice : Lis les tests).

Pour une liste non vide, garde à l'esprit que nous voulons utiliser notre constructeur de liste `Cons`. Bien que la liste actuelle soit composée d'entiers (`i32`), n'hésite pas à modifier la définition et essayer d'autres types !"""

[[exercises]]
name = "rc1"
dir = "19_smart_pointers"
hint = """
Ceci est un exercice simple pour utiliser le type `Rc<T>` (Référence Comptée). Chaque `Planète` possède le `Soleil`, et utilise `Rc::clone()` pour incrémenter le compteur de références du `Soleil`.

Après avoir utilisé `drop()` pour faire sortir individuellement les `Planète`s de leur portée, le nombre de références diminue.

À la fin, le `Soleil` n'a de nouveau qu'une seule référence, à lui-même.

Voir plus de détails ici : https://jimskapt.github.io/rust-book-fr/ch15-04-rc.html

Malheureusement, Pluton n'est plus considérée comme une planète :("""

[[exercises]]
name = "arc1"
dir = "19_smart_pointers"
test = false
hint = """
Transforme `shared_numbers` en un `Arc` (Compteur de Références Atomiques) à partir du vecteur `numbers`. Ensuite, pour éviter de créer une copie de `numbers`, tu devras créer `child_numbers` à l'intérieur de la boucle, mais toujours dans le thread principal.

`child_numbers` devrait être un clone de l'`Arc` des nombres plutôt qu'une copie locale des nombres.

C'est un exercice simple si tu comprends les concepts sous-jacents, mais si tu trouves cela trop difficile, envisage de lire l'intégralité du Chapitre 16 dans Le rust book :
https://jimskapt.github.io/rust-book-fr/ch16-00-concurrency.html"""

[[exercises]]
name = "cow1"
dir = "19_smart_pointers"
hint = """
Si `Cow` possède déjà les données, elle n'a pas besoin de les cloner lorsque `to_mut()` est appelée.

Consulte la documentation du type `Cow` :
https://doc.rust-lang.org/std/borrow/enum.Cow.html"""

# THREADS

[[exercises]]
name = "threads1"
dir = "20_threads"
test = false
hint = """
`JoinHandle` est une structure (struct) qui est retournée par un thread créé :
https://doc.rust-lang.org/std/thread/fn.spawn.html

Le défi avec les applications multi-threadées (multi-processus) est que le thread principal peut
se terminer avant que les threads créés ne soient finis.
https://jimskapt.github.io/rust-book-fr/ch16-01-threads.html#attendre-que-toutes-les-t%C3%A2ches-aient-fini-en-utilisant-join

Utilise les `JoinHandle` pour attendre que chaque thread se termine et récupérer leurs
résultats.

https://doc.rust-lang.org/std/thread/struct.JoinHandle.html"""

[[exercises]]
name = "threads2"
dir = "20_threads"
test = false
hint = """
`Arc` est un pointeur de Comptage de Références Atomique (Atomic Reference Counted) qui permet un accès sûr et partagé
à des données **immuables**. Mais nous voulons *modifier* le nombre de `jobs_done`, donc
nous aurons besoin d'utiliser un autre type qui ne permettra qu'à un seul thread de modifier
les données à la fois. Jette un œil à cette section du livre :
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct

Continue ta lecture si tu veux plus d'indices :)

As-tu maintenant un `Arc<Mutex<JobStatus>>` au début de `main` ? Comme :
```
let status = Arc::new(Mutex::new(JobStatus { jobs_done: 0 }));
```

Similaire au code de l'exemple suivant dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch16-03-shared-state.html#partager-un-mutext-entre-plusieurs-t%C3%A2ches"""

[[exercises]]
name = "threads3"
dir = "20_threads"
hint = """
Une autre façon de gérer la concurrence entre threads est d'utiliser un canal `mpsc`
(multiple producteurs, un seul consommateur - multiple producer, single consumer).

Avec un côté émetteur et un côté récepteur, il est possible d'envoyer des valeurs dans un thread et de les recevoir dans un autre.

Plusieurs producteurs sont possibles en utilisant `clone()` pour créer un duplicata de l'émetteur
original.

Section correspondante dans le rust book :
https://jimskapt.github.io/rust-book-fr/ch16-02-message-passing.html"""

# MACROS

[[exercises]]
name = "macros1"
dir = "21_macros"
test = false
hint = """
Lorsque tu appelles une macro (macro), tu dois ajouter quelque chose de spécial par rapport à un appel de fonction classique."""

[[exercises]]
name = "macros2"
dir = "21_macros"
test = false
hint = """
Les macros ne suivent pas tout à fait les mêmes règles que le reste de Rust, en termes de ce qui est disponible où.

Contrairement aux autres éléments de Rust, l'ordre entre "l'endroit où tu définis une macro" et "l'endroit où tu l'utilises" importe réellement."""

[[exercises]]
name = "macros3"
dir = "21_macros"
test = false
hint = """
Pour utiliser une macro en dehors de son module, tu dois faire quelque chose de spécial au module pour la faire remonter vers son parent."""

[[exercises]]
name = "macros4"
dir = "21_macros"
test = false
hint = """
Tu n'as besoin que d'ajouter un seul caractère pour faire compiler ce code.

La façon dont les macros sont écrites, elle veut voir quelque chose entre chaque "macro arm", pour pouvoir les séparer.

C'est tout ce que nous avons comme exercices de macros ici, mais c'est à peine un aperçu de ce que tu peux faire avec les macros de Rust. Pour une introduction plus approfondie, tu peux lire 'The Little Book of Rust Macros' :
https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
Rust stocke les versions les plus précises de certaines constantes mathématiques à haute précision dans sa bibliothèque standard :
https://doc.rust-lang.org/stable/std/f32/consts/index.html

Tu pourrais être tenté d'utiliser tes propres approximations pour certaines constantes mathématiques, mais clippy identifie ces approximations imprécises comme source potentielle d'erreurs.

Consulte les suggestions dans l'avertissement Clippy qui apparaît lors de la compilation et utilise plutôt la constante appropriée fournie par `std::f32::consts`."""

[[exercises]]
name = "clippy2"
dir = "22_clippy"
test = false
strict_clippy = true
hint = """
Les boucles `for` sur des valeurs `Option` sont plus clairement exprimées avec une instruction `if-let`.

Cette information n'est pas nécessaire pour résoudre cet exercice, mais si tu es intéressé par les cas où itérer sur `Option` peut être utile, consulte la section suivante dans la documentation :
https://doc.rust-lang.org/std/option/#iterating-over-option"""

[[exercises]]
name = "clippy3"
dir = "22_clippy"
test = false
strict_clippy = true
hint = "Pas d'indices cette fois !"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
dir = "23_conversions"
hint = """
Utilise l'opérateur `as` pour convertir l'un des opérandes dans la dernière ligne de la fonction `average` vers le type de retour attendu."""

[[exercises]]
name = "from_into"
dir = "23_conversions"
hint = """
Suis les étapes juste avant l'implémentation de `From`."""

[[exercises]]
name = "from_str"
dir = "23_conversions"
hint = """
L'implémentation de `FromStr` doit retourner un `Ok` avec un objet `Person`, ou un `Err` avec une erreur si la chaîne n'est pas valide.

C'est presque comme l'exercice précédent `from_into`, mais en retournant des erreurs au lieu de revenir à une valeur par défaut.

Un autre indice : Tu peux utiliser la méthode `map_err` de `Result` avec une fonction ou une closure pour encapsuler l'erreur de `parse::<u8>`.

Encore un indice : Si tu souhaites propager les erreurs en utilisant l'opérateur `?` dans ta solution, tu pourrais consulter
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "try_from_into"
dir = "23_conversions"
hint = """
Y a-t-il une implémentation de `TryFrom` dans la bibliothèque standard qui peut à la fois effectuer la conversion d'entier requise et vérifier la plage d'entrée ?

Défi : Peux-tu rendre les implémentations de `TryFrom` génériques pour plusieurs types d'entiers ?"""

[[exercises]]
name = "as_ref_mut"
dir = "23_conversions"
hint = """
Ajoute `AsRef<str>` ou `AsMut<u32>` comme contrainte de trait aux fonctions."""
